---
description: Project General Plan 
globs: 
---
תוכנית פעולה מלאה לבניית סוכן ניהול חנות E-Commerce
1. הקמת סביבת פיתוח ופרויקט בסיסי
צור תיקיית פרויקט (למשל: ecom_store_manager/).

צור קובץ requirements.txt שיכיל את הספריות שנשתמש בהן (למשל):

text
Copy
Edit
python-dotenv==1.0.1
pydantic==1.10.7
fastapi==0.95.2
uvicorn==0.27.1

requests==2.31.0
woocommerce==3.0.0

# AI / LLM
openai==0.27.6
langchain==0.0.XXX

# DB & Migrations
sqlalchemy==2.0.10
alembic==1.10.2

# אם נרצה רקע Celery, Redis, וכו’ (אופציונלי)
celery==5.2.7
redis==4.5.1
צור קובץ .env (ונוסיף ל-.gitignore) ובתוכו משתני סביבה:

ini
Copy
Edit
TELEGRAM_BOT_TOKEN="..."
WC_STORE_URL="https://example.com"
WC_CONSUMER_KEY="ck_..."
WC_CONSUMER_SECRET="cs_..."
OPENAI_API_KEY="sk-..."
התקן הכל בטרמינל (או דרך Cursor AI):

bash
Copy
Edit
pip install -r requirements.txt
2. מבנה תיקיות וקבצים (High-Level)
מומלץ מבנה בסגנון:

bash
Copy
Edit
ecom_store_manager/
├── .env
├── requirements.txt
├── src/
│   ├── main.py
│   ├── orchestrator.py           # סוכן ראשי
│   ├── bot.py                    # בוט טלגרם (או API) - אופציונלי
│   ├── agents/
│   │   ├── information_agent.py  # סוכן מידע
│   │   ├── action_agent.py       # סוכן פעולות
│   │   ├── research_agent.py     # סוכן מחקר
│   │   └── ...
│   ├── core/
│   │   ├── config.py             # Pydantic Settings
│   │   ├── db.py                 # התחברות DB (אופציונלי)
│   │   ├── memory.py             # זיכרון לשיחות (Vector DB וכו')
│   │   └── ...
│   ├── utils/
│   │   ├── logger.py
│   │   └── ...
│   └── ...
└── ...
הערה: המבנה גמיש, העיקר שיהיה ברור היכן ממוקמים הסוכנים, הסוכן הראשי, והקבצים הרלוונטיים.

3. דיאגרמת ארכיטקטורה
markdown
Copy
Edit
                   (משתמש/טלגרם/Web)   
                          │
                          ▼
                ┌───────────────────────────┐
                │  Orchestrator (סוכן ראשי) │
                │   מזהה כוונה/שאלה        │
                └──────────┬───────────────┘
         ┌─────────────────┴─────────────────┐
         ▼                                   ▼
┌───────────────────────┐          ┌───────────────────────┐
│Information Agent       │          │Action Agent           │
│(שואל WooCommerce/DB)   │          │(מבצע פעולות ב-API)    │
└───────────────────────┘          └───────────────────────┘
         ▼                                   ▼
         │                                   │
         │  קריאות HTTP                      │  קריאות HTTP
         ▼                                   ▼
  ┌───────────────────────┐          ┌───────────────────────┐
  │WooCommerce REST / DB  │          │WooCommerce REST / DB  │
  └───────────────────────┘          └───────────────────────┘
         │                                   │
         └─────────[תשובות]──────────────────┘

         ┌───────────────────────────────────┐
         │Research Agent (מחקר מתחרים וכו') │
         └───────────────────────────────────┘
                    │
                    │   קריאות Web Search / APIs
                    ▼
       ┌──────────────────────────────────────┐
       │ אתרים חיצוניים, Google, מתחרים וכו' │
       └──────────────────────────────────────┘

                 ┌────────────────────────┐
                 │ LLM (LangChain/OpenAI) │
                 └────────────────────────┘
                     ↑       │
                     │[פענוח כוונה,
                     │ כתיבת תשובות,
                     │ Chain-of-thought ]
                     
הערות:

הסוכן הראשי (Orchestrator) מקבל את בקשת המשתמש.
מחליט אם זו בקשה להציג מידע (Information Agent), לבצע פעולה (Action Agent) או לערוך מחקר (Research Agent).
הוא יכול להיעזר ב-LLM (LangChain) כדי להבין את הטקסט, או כדי לייצר תשובות משוכללות.
הסוכנים קוראים ל-API של WooCommerce (או DB) ומחזירים תוצאות לסוכן הראשי, אשר מחזיר למשתמש.
4. קטעי קוד עיקריים – שלד הבנייה
4.1 config.py (Pydantic Settings)
python
Copy
Edit
# src/core/config.py
import os
from pydantic import BaseSettings

class Settings(BaseSettings):
    wc_store_url: str
    wc_consumer_key: str
    wc_consumer_secret: str
    openai_api_key: str = ""

    class Config:
        env_file = ".env"

settings = Settings()
כעת, בכל מקום נוכל לכתוב: from core.config import settings כדי לגשת ל־settings.wc_store_url, וכו’.
4.2 information_agent.py
python
Copy
Edit
# src/agents/information_agent.py
import requests
from woocommerce import API
from core.config import settings

class InformationAgent:
    def __init__(self):
        self.wcapi = API(
            url=settings.wc_store_url,
            consumer_key=settings.wc_consumer_key,
            consumer_secret=settings.wc_consumer_secret,
            version="wc/v3"
        )

    def handle_message(self, user_message: str) -> str:
        # מזהה מה המשתמש מחפש (מוצרים, הזמנות, וכו')
        if "מוצרים" in user_message:
            return self.get_products()
        elif "דוח מכירות" in user_message:
            return self.get_sales_report()
        # ...
        return "לא זיהיתי מידע ספציפי."

    def get_products(self, page=1, per_page=5) -> str:
        response = self.wcapi.get("products", params={"page": page, "per_page": per_page})
        # עיבוד התשובה, החזרת טקסט ידידותי
        # ...

    def get_sales_report(self) -> str:
        response = self.wcapi.get("reports/sales?period=week")
        # עיבוד, החזרת דוח
        # ...
4.3 action_agent.py
python
Copy
Edit
# src/agents/action_agent.py
from woocommerce import API
from core.config import settings

class ActionAgent:
    def __init__(self):
        self.wcapi = API(
            url=settings.wc_store_url,
            consumer_key=settings.wc_consumer_key,
            consumer_secret=settings.wc_consumer_secret,
            version="wc/v3"
        )

    def handle_message(self, user_message: str) -> str:
        if "הוסף מוצר" in user_message:
            return self.create_product(...)
        # ...
        return "לא הבנתי איזו פעולה לבצע."

    def create_product(self, product_data: dict) -> str:
        resp = self.wcapi.post("products", product_data)
        # חזרת מחרוזת 
        # ...
4.4 research_agent.py
python
Copy
Edit
# src/agents/research_agent.py

import requests

class ResearchAgent:
    def handle_message(self, user_message: str) -> str:
        if "מתחרים" in user_message or "מחקר" in user_message:
            return self.search_competitors(...)
        return "לא זיהיתי נושא מחקר."

    def search_competitors(self, keyword: str) -> str:
        # לדוגמה: קריאה ל-Google Search API, אח”כ עיבוד
        return f"מצאתי תוצאות עבור {keyword}..."
4.5 orchestrator.py (הסוכן הראשי)
python
Copy
Edit
# src/orchestrator.py
from agents.information_agent import InformationAgent
from agents.action_agent import ActionAgent
from agents.research_agent import ResearchAgent

class Orchestrator:
    def __init__(self):
        self.info_agent = InformationAgent()
        self.action_agent = ActionAgent()
        self.research_agent = ResearchAgent()

    def handle_user_message(self, user_message: str) -> str:
        # לדוגמה, מנגנון פשוט לזיהוי כוונה
        if any(word in user_message for word in ["מוצרים", "דוח", "קופונים"]):
            return self.info_agent.handle_message(user_message)
        elif any(word in user_message for word in ["צור מוצר", "הוסף מוצר", "יצירת קופון"]):
            return self.action_agent.handle_message(user_message)
        elif any(word in user_message for word in ["מתחרים", "מחקר"]):
            return self.research_agent.handle_message(user_message)

        # אחרת, fallback
        return "לא ברור מה תרצה לעשות. שאל על מידע, פעולה או מחקר!"
5. אינטגרציה עם LangChain וה-LLM
התקן LangChain (כבר ב־requirements.txt) + ספרייה של ספק LLM, למשל openai.

הגדר מודל (למשל GPT-3.5) וקונפיג:

python
Copy
Edit
# src/core/llm.py
import os
import openai
from langchain.llms import OpenAI

openai.api_key = os.getenv("OPENAI_API_KEY")

llm = OpenAI(temperature=0.3, model_name="gpt-3.5-turbo")
סוכן הראשי יכול להיעזר במודל כדי לנתח כוונה:

python
Copy
Edit
# באורקסטרייטור
from langchain.prompts import PromptTemplate

prompt_template = PromptTemplate(
    input_variables=["user_message"],
    template="""
    אתה עוזר חכם לניהול חנות.
    סווג את השאלה הבאה לקטגוריה: [פעולה, מידע, מחקר, אחר].
    שאלה: {user_message}
    """
)

classification = llm(prompt_template.format(user_message=user_message))
# כעת נאמר if "פעולה" in classification: לקרוא לסוכן הפעולות, וכו'
יצירת Chain / Agent עם Tools:

אפשר להגדיר Tool שמפנה ל–information_agent.get_products(), Tool שמפנה ל–action_agent.create_product(), וכו’, ואז לתת לסוכן ב-LangChain “להחליט” מתי להשתמש בכל כלי. (זו ארכיטקטורה מתקדמת יותר).
6. אופציונלי: בוט טלגרם או ממשק Web
בוט טלגרם: יצירת bot.py שמשתמש בספריית python-telegram-bot, ומפנה את ההודעות ל-Orchestrator:
python
Copy
Edit
# src/bot.py
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters
from orchestrator import Orchestrator

orchestrator = Orchestrator()

async def handle(update, context):
    user_message = update.message.text
    response = orchestrator.handle_user_message(user_message)
    await update.message.reply_text(response)

def run_bot():
    app = ApplicationBuilder().token("TELEGRAM_BOT_TOKEN").build()
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle))
    app.run_polling()
FastAPI: אם מעדיפים API רסט, מגדירים endpoints ב–main.py:
python
Copy
Edit
# src/main.py
from fastapi import FastAPI
from orchestrator import Orchestrator

app = FastAPI()
o = Orchestrator()

@app.post("/ask")
def ask_something(user_message: str):
    return {"answer": o.handle_user_message(user_message)}
ואז מריצים uvicorn main:app --reload.
7. ניהול DB (SQLAlchemy + Alembic) – רשות
אם צריך לשמור היסטוריית שיחות, Audit של פעולות וכו’, ניתן:
להגדיר מודלים Pythonic עם SQLAlchemy (הגדרת טבלאות).
להשתמש ב־Alembic למיגרציות.
לקרוא/לכתוב DB כשמבצעים פעולה ב–ActionAgent, או כשמגיבים לשאילתת המשתמש.
8. הרחבות אפשריות
Caching: אם התשובה חוזרת על עצמה (“הצג דוח מכירות” כל דקה), אפשר לשמור Cache.
סוכן מחקר מפותח: קריאה ל–Google Search API, ניתוח טקסט, אולי Embeddings + Summaries.
זיכרון שיחה (Memory): להשתמש ב–LangChain’s ConversationalBufferMemory או ב–Vector DB, כך שהסוכן “זוכר” מה נאמר לפני 5 שאלות.
Workflow מתקדם: סוכן יכול לשאול Clarification (“איזה מחיר ברצונך להגדיר?”) לפני שמבצע פעולה.
9. מסמך נקודות הגנה ושיפור
אבטחה: לא לאפשר לסוכן ל”מחוק את כל המוצרים” ללא אישור מפורש.
הרשאות: שמור מזהה משתמש (אם בטלגרם: user_id). בדוק האם מותר לו לבצע פעולות קריטיות.
גיבוי ושחזור: לפני שינויי מאסיביים, ערוך Snapshot.
ניטור: Observability (למשל לוגים ב–logger.py, או שימוש ב–Sentry).
סבבי פיתוח: הוצא MVP שמציג מידע בלבד (READ). אח”כ הוסף עדכוני Write. לבסוף: הוסף יכולות מחקר, וכו’.
10. סיכום
להלן הRoadmap ב–Cursor AI:

הקמת סביבת פרויקט – requirements.txt, .env, מבנה תיקיות.
Config והתחברות – config.py, הגדרת משתני סביבה (WooCommerce API וכו’).
Agent עיקריים:
InformationAgent (שליפת נתונים)
ActionAgent (פעולות כתיבה)
ResearchAgent (חיפוש חיצוני).
Orchestrator – מנגנון נתב: “איזה Agent מטפל בשאילתה?”
LLM Integration – שימוש ב–LangChain / OpenAI.
Frontend / Interface – בוט טלגרם או FastAPI.
בדיקות ושיפורים – בדיקת פעולות, דוחות, מסמכי לוג, הוספת אבטחה.
בהמשך ניתן להוסיף: “זיכרון שיחה משופר” (Memory), מחקר מתקדם, מנגנוני Celery למשימות רקע, ניהול DB עם SQLAlchemy, ועוד.

בכך יש לנו:
תמונת-על של הפרויקט
דיאגרמה שמציגה את הזרימה
קטעי קוד שלד לכל רכיב עיקרי
המלצות לספריות ולגישות
תוכנית זו אמורה לשמש כבסיס. בכל שלב שאתה מתקדם, חזור לכאן, וודא שאתה עומד ברשימה הנ”ל ומרחיב לפי הצורך. בהצלחה!







